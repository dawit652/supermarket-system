here is the clasese in my pc  package com.supermarket.presentation.controllers;

import com.supermarket.application.models.Branch;
import com.supermarket.application.services.BranchService;
import com.supermarket.application.services.ProductService;
import com.supermarket.application.models.Product;
import com.supermarket.presentation.App;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.HBox;
import javafx.util.Callback;

import java.sql.SQLException;
import java.util.List;

public class InventoryController {
    @FXML
    private ComboBox<Branch> branchComboBox; // Ensure this matches the fx:id in FXML
    @FXML
    private TableView<Product> productTable;
    @FXML
    private TableColumn<Product, Integer> idColumn;
    @FXML
    private TableColumn<Product, String> nameColumn;
    @FXML
    private TableColumn<Product, String> barcodeColumn;
    @FXML
    private TableColumn<Product, Double> priceColumn;
    @FXML
    private TableColumn<Product, Integer> stockColumn;
    @FXML
    private TextField nameField;
    @FXML
    private TextField barcodeField;
    @FXML
    private TextField priceField;
    @FXML
    private TextField stockField;
    private App app;

    private BranchService branchService = new BranchService();
    private final ProductService productService = new ProductService();
    private final ObservableList<Product> products = FXCollections.observableArrayList();



    @FXML
    public void initialize() {
        System.out.println("Initializing InventoryController...");

        // Set up table columns
        idColumn.setCellValueFactory(new PropertyValueFactory<>("id"));
        nameColumn.setCellValueFactory(new PropertyValueFactory<>("name"));
        barcodeColumn.setCellValueFactory(new PropertyValueFactory<>("barcode"));
        priceColumn.setCellValueFactory(new PropertyValueFactory<>("price"));
        stockColumn.setCellValueFactory(new PropertyValueFactory<>("stock"));



        // Add Actions column with Update and Delete buttons
        TableColumn<Product, Void> actionsColumn = new TableColumn<>("Actions");
        actionsColumn.setPrefWidth(180);
        actionsColumn.setCellFactory(new Callback<TableColumn<Product, Void>, TableCell<Product, Void>>() {
            @Override
            public TableCell<Product, Void> call(TableColumn<Product, Void> param) {
                return new TableCell<Product, Void>() {
                    private final Button updateButton = new Button("Update");
                    private final Button deleteButton = new Button("Delete");

                    {
                        // Update button action
                        updateButton.setOnAction(event -> {
                            Product product = getTableView().getItems().get(getIndex());
                            updateProduct(product);
                        });

                        // Delete button action
                        deleteButton.setOnAction(event -> {
                            Product product = getTableView().getItems().get(getIndex());
                            deleteProduct(product);
                        });
                    }

                    @Override
                    protected void updateItem(Void item, boolean empty) {
                        super.updateItem(item, empty);
                        if (empty) {
                            setGraphic(null);
                        } else {
                            HBox buttons = new HBox(5, updateButton, deleteButton);
                            setGraphic(buttons);
                        }
                    }
                };
            }
        });

        // Add the Actions column to the table
        productTable.getColumns().add(actionsColumn);

        // Add listener for product selection
        productTable.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                // Populate input fields with selected product's data
                nameField.setText(newValue.getName());
                barcodeField.setText(newValue.getBarcode());
                priceField.setText(String.valueOf(newValue.getPrice()));
                stockField.setText(String.valueOf(newValue.getStock()));
            }
        });

        try {
            // Load branches into the ComboBox
            List<Branch> branches = branchService.getAllBranches();
            branchComboBox.setItems(FXCollections.observableArrayList(branches));
            System.out.println("Branches loaded: " + branches.size());

            // Add listener for branch selection
            branchComboBox.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
                if (newValue != null) {
                    System.out.println("Selected branch: " + newValue.getName());
                    loadProducts(newValue.getId());
                }
            });
        } catch (SQLException e) {
            showError("Failed to load branches: " + e.getMessage());
        }
    }

    public void setApp(App app) {
        this.app = app;
    }

    private void loadProducts(int branchId) {
        try {
            products.clear();
            List<Product> productList = productService.getAllProducts(branchId);
            products.addAll(productList);
            productTable.setItems(products);
            System.out.println("Products loaded: " + productList.size());
        } catch (SQLException e) {
            showError("Failed to load products: " + e.getMessage());
        }
    }

    @FXML
    private void addProduct() {
        try {
            String name = nameField.getText();
            String barcode = barcodeField.getText();
            double price = Double.parseDouble(priceField.getText());
            int stock = Integer.parseInt(stockField.getText());
            int branchId = branchComboBox.getValue().getId();

            Product product = new Product(name, barcode, price, stock, branchId);
            productService.addProduct(product);
            loadProducts(branchId);

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (NumberFormatException e) {
            showError("Invalid input. Please check the price and stock fields.");
        } catch (SQLException e) {
            showError("Failed to add product: " + e.getMessage());
        } catch (NullPointerException e) {
            showError("Please select a branch before adding a product.");
        }
    }
    @FXML
    private void updateProduct(Product product) {
        try {
            // Get updated values from input fields
            String name = nameField.getText();
            String barcode = barcodeField.getText();
            double price = Double.parseDouble(priceField.getText());
            int stock = Integer.parseInt(stockField.getText());

            // Update the selected product
            product.setName(name);
            product.setBarcode(barcode);
            product.setPrice(price);
            product.setStock(stock);

            // Save changes to the database
            productService.updateProduct(product);

            // Refresh the table
            loadProducts(product.getBranchId());

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (NumberFormatException e) {
            showError("Invalid input. Please check the price and stock fields.");
        } catch (SQLException e) {
            showError("Failed to update product: " + e.getMessage());
        }
    }

    @FXML
    private void deleteProduct(Product product) {
        try {
            // Delete the selected product from the database
            productService.deleteProduct(product.getId());

            // Refresh the table
            loadProducts(product.getBranchId());

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (SQLException e) {
            showError("Failed to delete product: " + e.getMessage());
        }
    }

    private void showError(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}                                                                         <?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.HBox?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.supermarket.presentation.controllers.InventoryController" spacing="10">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Title -->
    <Label text="Product Management" style="-fx-font-size: 20; -fx-font-weight: bold;" />

    <!-- Branch Selection -->
    <HBox spacing="10">
        <ComboBox fx:id="branchComboBox" promptText="Select Branch" prefWidth="200" />
    </HBox>

    <!-- Input Fields -->
    <HBox spacing="10">
        <TextField fx:id="nameField" promptText="Enter product name" prefWidth="150" />
        <TextField fx:id="barcodeField" promptText="Enter barcode" prefWidth="150" />
        <TextField fx:id="priceField" promptText="Enter price" prefWidth="100" />
        <TextField fx:id="stockField" promptText="Enter stock" prefWidth="100" />
        <Button text="Add Product" onAction="#addProduct" style="-fx-font-weight: bold;" />
    </HBox>

    <!-- Product Table -->
    <TableView fx:id="productTable" prefHeight="300">
        <columns>
            <TableColumn fx:id="idColumn" text="ID" prefWidth="50" />
            <TableColumn fx:id="nameColumn" text="Name" prefWidth="150" />
            <TableColumn fx:id="barcodeColumn" text="Barcode" prefWidth="150" />
            <TableColumn fx:id="priceColumn" text="Price" prefWidth="100" />
            <TableColumn fx:id="stockColumn" text="Stock" prefWidth="100" />
        </columns>
    </TableView>
</VBox>                                                      package com.supermarket.data.dao;

import com.supermarket.application.models.Product;
import com.supermarket.data.DatabaseConnection;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class InventoryDAO {
    /**
     * Fetches all products with their stock levels for a specific branch.
     *
     * @param branchId The ID of the branch.
     * @return A list of products with stock levels.
     * @throws SQLException If a database error occurs.
     */
    public List<Product> getProductsByBranch(int branchId) throws SQLException {
        List<Product> products = new ArrayList<>();
        String sql = "SELECT id, name, barcode, price, stock FROM product WHERE branch_id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, branchId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    String barcode = rs.getString("barcode");
                    double price = rs.getDouble("price");
                    int stock = rs.getInt("stock");
                    products.add(new Product(id, name, barcode, price, stock, branchId));
                }
            }
        }
        return products;
    }

    /**
     * Updates the stock level of a product.
     *
     * @param product The product with updated stock level.
     * @throws SQLException If a database error occurs.
     */
    public void updateStock(Product product) throws SQLException {
        String sql = "UPDATE product SET stock = ? WHERE id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, product.getStock());
            stmt.setInt(2, product.getId());
            stmt.executeUpdate();
        }
    }

    /**
     * Fetches products with stock below a threshold.
     *
     * @param branchId The ID of the branch.
     * @param threshold The stock threshold.
     * @return A list of products with low stock.
     * @throws SQLException If a database error occurs.
     */
    public List<Product> getLowStockProducts(int branchId, int threshold) throws SQLException {
        List<Product> lowStockProducts = new ArrayList<>();
        String sql = "SELECT id, name, barcode, price, stock FROM product WHERE branch_id = ? AND stock <= ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, branchId);
            stmt.setInt(2, threshold);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    String barcode = rs.getString("barcode");
                    double price = rs.getDouble("price");
                    int stock = rs.getInt("stock");
                    lowStockProducts.add(new Product(id, name, barcode, price, stock, branchId));
                }
            }
        }
        return lowStockProducts;
    }

    /**
     * Syncs offline inventory changes with the central database.
     *
     * @throws SQLException If a database error occurs.
     */
    public void syncOfflineChanges() throws SQLException {
        String sql = "INSERT INTO product (name, barcode, price, stock, branch_id) SELECT name, barcode, price, stock, branch_id FROM offline_product";
        try (Connection conn = DatabaseConnection.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate(sql);
        }
    }
}                                                                                             package com.supermarket.application.services;

import com.supermarket.application.models.Product;
import com.supermarket.data.dao.InventoryDAO;

import java.sql.SQLException;
import java.util.List;

public class InventoryService {
    private final InventoryDAO inventoryDAO;

    public InventoryService() {
        this.inventoryDAO = new InventoryDAO();
    }

    /**
     * Fetches all products with their stock levels for a specific branch.
     *
     * @param branchId The ID of the branch.
     * @return A list of products with stock levels.
     * @throws SQLException If a database error occurs.
     */
    public List<Product> getInventoryForBranch(int branchId) throws SQLException {
        return inventoryDAO.getProductsByBranch(branchId);
    }

    /**
     * Updates the stock level of a product.
     *
     * @param product The product with updated stock level.
     * @throws SQLException If a database error occurs.
     */
    public void updateStock(Product product) throws SQLException {
        if (product.getStock() < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        inventoryDAO.updateStock(product);
    }

    /**
     * Generates low-stock alerts for products below a threshold.
     *
     * @param branchId The ID of the branch.
     * @param threshold The stock threshold.
     * @return A list of products with low stock.
     * @throws SQLException If a database error occurs.
     */
    public List<Product> getLowStockAlerts(int branchId, int threshold) throws SQLException {
        return inventoryDAO.getLowStockProducts(branchId, threshold);
    }

    /**
     * Syncs offline inventory changes with the central database.
     *
     * @throws SQLException If a database error occurs.
     */
    public void syncOfflineInventory() throws SQLException {
        inventoryDAO.syncOfflineChanges();
    }
}                                                                                 package com.supermarket.application.models;

public class Inventory {
}
                                                          package com.supermarket.data;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.sql.Connection;
import java.sql.SQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DatabaseConnection {
    private static final Logger logger = LoggerFactory.getLogger(DatabaseConnection.class);
    private static final String DATABASE_NAME = "supermarket.db";
    private static HikariDataSource dataSource;

    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(getDatabaseURL());
        config.setMaximumPoolSize(10);
        config.setIdleTimeout(30000);
        config.setMaxLifetime(1800000);
        config.setConnectionTimeout(10000);
        config.setAutoCommit(true);
        dataSource = new HikariDataSource(config);
    }

    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    private static String getDatabaseURL() {
        // Absolute path for development (adjust based on your system)
        String dbPath = "C:\\Users\\dawit\\Desktop\\supermarket-system\\src\\main\\resources\\supermarket.db";

        // Check if the file exists
        File dbFile = new File(dbPath);
        if (!dbFile.exists()) {
            logger.error("Database file not found at: {}", dbPath);
            throw new RuntimeException("Database file not found at: " + dbPath);
        }

        // Return the JDBC URL for SQLite
        return "jdbc:sqlite:" + dbPath;
    }

    public static void closeDataSource() {
        if (dataSource != null) {
            dataSource.close();
            logger.info("Database connection pool closed.");
        }
    }
}                                                                   package com.supermarket.application.models;

public class Product {
    private int id;
    private String name;
    private String barcode;
    private double price;
    private int stock;
    private int branchId;

    // Constructor with ID (for fetching from the database)
    public Product(int id, String name, String barcode, double price, int stock, int branchId) {
        this.id = id;
        this.name = name;
        this.barcode = barcode;
        this.price = price;
        this.stock = stock;
        this.branchId = branchId;
    }

    // Constructor without ID (for creating new products)
    public Product(String name, String barcode, double price, int stock, int branchId) {
        this.name = name;
        this.barcode = barcode;
        this.price = price;
        this.stock = stock;
        this.branchId = branchId;
    }

    // Getters and Setters
    public int getId() { return id; }
    public String getName() { return name; }
    public String getBarcode() { return barcode; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }
    public int getBranchId() { return branchId; }

    public void setId(int id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setBarcode(String barcode) { this.barcode = barcode; }
    public void setPrice(double price) { this.price = price; }
    public void setStock(int stock) { this.stock = stock; }
    public void setBranchId(int branchId) { this.branchId = branchId; }
}                                                                  package com.supermarket.application.services;

import com.supermarket.application.models.Product;
import com.supermarket.data.dao.ProductDAO;
import java.sql.SQLException;
import java.util.List;

public class ProductService {
    private final ProductDAO productDAO;

    public ProductService() {
        this.productDAO = new ProductDAO();
    }

    // Add a new product with validation
    public void addProduct(Product product) throws SQLException, IllegalArgumentException {
        if (product.getPrice() <= 0) {
            throw new IllegalArgumentException("Price must be greater than 0.");
        }
        if (product.getStock() < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        productDAO.addProduct(product);
    }


    // Get all products
    public List<Product> getAllProducts(int branchId) throws SQLException {
        return productDAO.getAllProducts(branchId);
    }

    // Update a product
    public void updateProduct(Product product) throws SQLException, IllegalArgumentException {
        if (product.getPrice() <= 0) {
            throw new IllegalArgumentException("Price must be greater than 0.");
        }
        if (product.getStock() < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        productDAO.updateProduct(product);
    }

    // Delete a product
    public void deleteProduct(int id) throws SQLException {
        productDAO.deleteProduct(id);
    }



}                         i think  based on project structure both model.prodct and model.Inventory shares the same InventoryController class   so considering this update classes