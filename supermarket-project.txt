package com.supermarket.application.models;

public class User {
    private int id;
    private String username;
    private String password;
    private String role;
    private int branchId; // New field for branch association

    // Constructor with ID (for fetching from the database)
    public User(int id, String username, String password, String role, int branchId) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.role = role;
        this.branchId = branchId;
    }

    // Constructor without ID (for creating new users)
    public User(String username, String password, String role, int branchId) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.branchId = branchId;
    }

    // Getters and Setters
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public int getBranchId() {
        return branchId;
    }

    public void setBranchId(int branchId) {
        this.branchId = branchId;
    }
}                                                              package com.supermarket.application.services;

import com.supermarket.application.models.User;
import com.supermarket.data.dao.UserDAO;
import com.supermarket.utils.PasswordUtil;
import javafx.stage.Stage;

import java.sql.SQLException;
import java.util.List;

public class UserService {
    private final UserDAO userDAO;

    public UserService() {
        this.userDAO = new UserDAO();
    }

    /**
     * Adds a new user with a hashed password.
     *
     * @param user The user to add.
     * @throws SQLException If a database error occurs.
     */
    public void addUser(User user) throws SQLException {
        String hashedPassword = PasswordUtil.hashPassword(user.getPassword());
        user.setPassword(hashedPassword); // Replace plain-text password with hashed version
        userDAO.addUser(user);
    }

    /**
     * Updates an existing user with a hashed password if the password is updated.
     *
     * @param user The user to update.
     * @throws SQLException If a database error occurs.
     */


    /**
     * Fetches a user by username.
     *
     * @param username The username to search for.
     * @return The user object if found, null otherwise.
     * @throws SQLException If a database error occurs.
     */
    public User getUserByUsername(String username) throws SQLException {
        return userDAO.getUserByUsername(username);
    }

    /**
     * Authenticates a user by verifying their hashed password.
     *
     * @param username The username to authenticate.
     * @param password The plain-text password to verify.
     * @return True if authentication succeeds, false otherwise.
     * @throws SQLException If a database error occurs.
     */
    public boolean authenticate(String username, String password) throws SQLException {
        User user = userDAO.getUserByUsername(username);
        if (user != null) {
            String storedHash = user.getPassword();
            System.out.println("Stored Hash: " + storedHash); // Log the stored hash
            System.out.println("Input Password: " + password); // Log the input password
            boolean isMatch = PasswordUtil.verifyPassword(password, storedHash);
            System.out.println("Password Match: " + isMatch); // Log the result of verification
            return isMatch;
        }
        return false;
    }
    public List<User> getAllUsers() throws SQLException {
        return userDAO.getAllUsers(); // Delegate to the DAO layer
    }

    public void updateUser(User user) throws SQLException {
        if (!user.getPassword().startsWith("$2")) { // Check if the password is already hashed
            String hashedPassword = PasswordUtil.hashPassword(user.getPassword());
            user.setPassword(hashedPassword); // Replace plain-text password with hashed version
        }
        userDAO.updateUser(user);
    }


    /**
     * Deletes a user from the database.
     *
     * @param id The ID of the user to delete.
     * @throws SQLException If a database error occurs.
     */
    public void deleteUser(int id) throws SQLException {
        userDAO.deleteUser(id);
    }
}                                          package com.supermarket.data.dao;

import com.supermarket.application.models.User;
import com.supermarket.data.DatabaseConnection;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class UserDAO {
    /**
     * Adds a new user to the database.
     *
     * @param user The user to add.
     * @throws SQLException If a database error occurs.
     */
    public void addUser(User user) throws SQLException {
        String sql = "INSERT INTO users (username, password, role, branch_id) VALUES (?, ?, ?, ?)";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, user.getUsername());
            stmt.setString(2, user.getPassword()); // Password is already hashed
            stmt.setString(3, user.getRole());
            stmt.setInt(4, user.getBranchId());
            stmt.executeUpdate();
        }
    }

    /**
     * Fetches a user by username.
     *
     * @param username The username to search for.
     * @return The user object if found, null otherwise.
     * @throws SQLException If a database error occurs.
     */
    public User getUserByUsername(String username) throws SQLException {
        String sql = "SELECT * FROM users WHERE username = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, username);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return new User(
                            rs.getInt("id"),
                            rs.getString("username"),
                            rs.getString("password"), // Password is stored as a hash
                            rs.getString("role"),
                            rs.getInt("branch_id")
                    );
                }
            }
        }
        return null;
    }

    /**
     * Updates an existing user in the database.
     *
     * @param user The user to update.
     * @throws SQLException If a database error occurs.
     */
    public List<User> getAllUsers() throws SQLException {
        List<User> users = new ArrayList<>();
        String sql = "SELECT * FROM users";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                users.add(new User(
                        rs.getInt("id"),
                        rs.getString("username"),
                        rs.getString("password"),
                        rs.getString("role"),
                        rs.getInt("branch_id")
                ));
            }
        }
        return users;
    }

    public void updateUser(User user) throws SQLException {
        String sql = "UPDATE users SET username = ?, password = ?, role = ?, branch_id = ? WHERE id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, user.getUsername());
            stmt.setString(2, user.getPassword());
            stmt.setString(3, user.getRole());
            stmt.setInt(4, user.getBranchId());
            stmt.setInt(5, user.getId());
            stmt.executeUpdate();
        }
    }

    /**
     * Deletes a user from the database.
     *
     * @param id The ID of the user to delete.
     * @throws SQLException If a database error occurs.
     */
    public void deleteUser(int id) throws SQLException {
        String sql = "DELETE FROM users WHERE id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, id);
            stmt.executeUpdate();
        }
    }
}                                                   package com.supermarket.presentation.controllers;

import com.supermarket.application.models.Branch;
import com.supermarket.application.models.User;
import com.supermarket.application.services.BranchService;
import com.supermarket.application.services.UserService;
import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import java.sql.SQLException;
import java.util.List;

public class UserController {
    @FXML
    private TextField usernameField;
    @FXML
    private PasswordField passwordField;
    @FXML
    private ComboBox<String> roleComboBox;
    @FXML
    private ComboBox<Branch> branchComboBox;

    private final UserService userService = new UserService();
    private final BranchService branchService = new BranchService();

    @FXML
    public void initialize() {
        try {
            // Load branches into the ComboBox
            List<Branch> branches = branchService.getAllBranches();
            branchComboBox.setItems(FXCollections.observableArrayList(branches));
        } catch (SQLException e) {
            showError("Failed to load branches: " + e.getMessage());
        }
    }

    /**
     * Adds a new user with a plain-text password.
     */
    @FXML
    private void addUser() {
        String username = usernameField.getText();
        String password = passwordField.getText();
        String role = roleComboBox.getValue();
        Branch selectedBranch = branchComboBox.getValue();

        if (username.isEmpty() || password.isEmpty() || role == null || selectedBranch == null) {
            showError("Please fill in all fields.");
            return;
        }

        try {
            User user = new User(username, password, role, selectedBranch.getId());
            userService.addUser(user); // Password is hashed in the UserService
            showSuccess("User added successfully!");
            clearFields();
        } catch (SQLException e) {
            showError("Failed to add user: " + e.getMessage());
        }
    }

    /**
     * Updates an existing user with a plain-text password.
     */
    @FXML
    private void updateUser() {
        String username = usernameField.getText();
        String password = passwordField.getText();
        String role = roleComboBox.getValue();
        Branch selectedBranch = branchComboBox.getValue();

        if (username.isEmpty() || password.isEmpty() || role == null || selectedBranch == null) {
            showError("Please fill in all fields.");
            return;
        }

        try {
            User user = new User(0, username, password, role, selectedBranch.getId()); // ID is not needed here
            userService.updateUser(user); // Password is hashed in the UserService
            showSuccess("User updated successfully!");
            clearFields();
        } catch (SQLException e) {
            showError("Failed to update user: " + e.getMessage());
        }
    }

    private void showError(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }

    private void showSuccess(String message) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Success");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }

    private void clearFields() {
        usernameField.clear();
        passwordField.clear();
        roleComboBox.setValue(null);
        branchComboBox.setValue(null);
    }
}                                             package com.supermarket.utils;

import org.mindrot.jbcrypt.BCrypt;

public class PasswordHashGenerator {
    public static void main(String[] args) {
        String plainPassword = "admin123"; // Replace with the desired password
        String hashedPassword = BCrypt.hashpw(plainPassword, BCrypt.gensalt(10)); // Cost factor of 10
        System.out.println("Hashed Password: " + hashedPassword);
    }
}                                                 package com.supermarket.utils;

import org.mindrot.jbcrypt.BCrypt;

public class PasswordUtil {
    /**
     * Hashes the given password using BCrypt.
     *
     * @param password Plain-text password to hash.
     * @return The hashed password.
     */
    public static String hashPassword(String password) {
        return BCrypt.hashpw(password, BCrypt.gensalt(10)); // Cost factor of 10
    }

    /**
     * Verifies if the plain-text password matches the hashed password.
     *
     * @param plainPassword The plain-text password to verify.
     * @param hashedPassword The hashed password from the database.
     * @return True if the passwords match, false otherwise.
     */
    public static boolean verifyPassword(String plainPassword, String hashedPassword) {
        if (hashedPassword == null || !hashedPassword.startsWith("$2")) {
            System.err.println("Invalid hashed password format: " + hashedPassword);
            return false;
        }
        return BCrypt.checkpw(plainPassword, hashedPassword);
    }
}                                      package com.supermarket.data;

import com.supermarket.application.models.User;
import com.supermarket.application.services.UserService;
import com.supermarket.utils.PasswordUtil;

import java.sql.SQLException;
import java.util.List;

public class PasswordUpdater {
    public static void main(String[] args) {
        UserService userService = new UserService();
        try {
            List<User> users = userService.getAllUsers(); // Fetch all users
            for (User user : users) {
                String storedPassword = user.getPassword();
                if (!storedPassword.startsWith("$2")) { // Check if the password is already hashed
                    String hashedPassword = PasswordUtil.hashPassword(storedPassword); // Hash the password
                    user.setPassword(hashedPassword); // Update the user object with the hashed password
                    userService.updateUser(user); // Save the updated user back to the database
                    System.out.println("Updated password for user: " + user.getUsername());
                } else {
                    System.out.println("Password already hashed for user: " + user.getUsername());
                }
            }
        } catch (SQLException e) {
            System.err.println("Failed to update passwords: " + e.getMessage());
        }
    }
}                                                             <?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.scene.control.Button?>

<?import javafx.scene.layout.HBox?>
<?import java.lang.String?>
<VBox xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.supermarket.presentation.controllers.LoginController" spacing="20" alignment="CENTER" prefWidth="400" prefHeight="300" style="-fx-padding: 20;">
    <!-- Stylesheet Reference -->
    <stylesheets>
        <String fx:value="/styles/styles.css" />
    </stylesheets>

    <!-- Title -->
    <Label text="Supermarket Login" style="-fx-font-size: 20; -fx-font-weight: bold;" />

    <!-- Username Field -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Username:" />
        <TextField fx:id="usernameField" promptText="Enter your username" prefWidth="200" />
    </HBox>

    <!-- Password Field -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Password:" />
        <PasswordField fx:id="passwordField" promptText="Enter your password" prefWidth="200" />
    </HBox>

    <!-- Branch Selection -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Branch:" />
        <ComboBox fx:id="branchComboBox" prefWidth="200" promptText="Select a branch" />
    </HBox>

    <!-- Login Button -->
    <Button text="Login" onAction="#handleLogin" style="-fx-background-color: #4CAF50; -fx-text-fill: white;" prefWidth="100" />

    <!-- Error Message (Optional) -->
    <Label fx:id="errorMessage" text="" style="-fx-text-fill: red;" visible="false" managed="false" />
</VBox>                                                     <?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.PasswordField?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.scene.control.Button?>

<?import javafx.scene.layout.HBox?>
<?import java.lang.String?>
<VBox xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.supermarket.presentation.controllers.LoginController" spacing="20" alignment="CENTER" prefWidth="400" prefHeight="300" style="-fx-padding: 20;">
    <!-- Stylesheet Reference -->
    <stylesheets>
        <String fx:value="/styles/styles.css" />
    </stylesheets>

    <!-- Title -->
    <Label text="Supermarket Login" style="-fx-font-size: 20; -fx-font-weight: bold;" />

    <!-- Username Field -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Username:" />
        <TextField fx:id="usernameField" promptText="Enter your username" prefWidth="200" />
    </HBox>

    <!-- Password Field -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Password:" />
        <PasswordField fx:id="passwordField" promptText="Enter your password" prefWidth="200" />
    </HBox>

    <!-- Branch Selection -->
    <HBox alignment="CENTER" spacing="10">
        <Label text="Branch:" />
        <ComboBox fx:id="branchComboBox" prefWidth="200" promptText="Select a branch" />
    </HBox>

    <!-- Login Button -->
    <Button text="Login" onAction="#handleLogin" style="-fx-background-color: #4CAF50; -fx-text-fill: white;" prefWidth="100" />

    <!-- Error Message (Optional) -->
    <Label fx:id="errorMessage" text="" style="-fx-text-fill: red;" visible="false" managed="false" />
</VBox>                                    package com.supermarket.application.models;

public class Branch {
    private int id;
    private String name;
    private String location;

    // Constructor
    public Branch(int id, String name, String location) {
        this.id = id;
        this.name = name;
        this.location = location;
    }

    // Getters and Setters
    public int getId() { return id; }
    public String getName() { return name; }
    public String getLocation() { return location; }

    public void setId(int id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setLocation(String location) { this.location = location; }

    // Override toString() to display branch name in ComboBox
    @Override
    public String toString() {
        return name;  // JavaFX will now display the branch name instead of the object reference
    }
}
                                                    package com.supermarket.application.services;

import com.supermarket.application.models.Branch;
import com.supermarket.data.dao.BranchDAO;

import java.sql.SQLException;
import java.util.List;

public class BranchService {
    private final BranchDAO branchDAO;

    public BranchService() {
        this.branchDAO = new BranchDAO();
    }

    public List<Branch> getAllBranches() throws SQLException {
        return branchDAO.getAllBranches();



    }
}
                                                     package com.supermarket.data.dao;

import com.supermarket.application.models.Branch;
import com.supermarket.data.DatabaseConnection;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class BranchDAO {
    public List<Branch> getAllBranches() {
        List<Branch> branches = new ArrayList<>();
        String query = "SELECT * FROM branches";

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {

            while (rs.next()) {
                System.out.println("Branch: " + rs.getString("name"));

                // Correctly construct the Branch object with the required arguments
                Branch branch = new Branch(
                        rs.getInt("id"),       // id
                        rs.getString("name"), // name
                        rs.getString("location") // location
                );
                System.out.println("Branches fetched: " + branches.size());
                branches.add(branch);
                System.out.println("Branches fetched: " + branches.size());
            }
        } catch (SQLException e) {
            System.err.println("Failed to fetch branches: " + e.getMessage());
        }

        return branches;
    }
}                                   package com.supermarket.application.models;

public class Product {
    private int id;
    private String name;
    private String barcode;
    private double price;
    private int stock;
    private int branchId;

    // Constructor with ID (for fetching from the database)
    public Product(int id, String name, String barcode, double price, int stock, int branchId) {
        this.id = id;
        this.name = name;
        this.barcode = barcode;
        this.price = price;
        this.stock = stock;
        this.branchId = branchId;
    }

    // Constructor without ID (for creating new products)
    public Product(String name, String barcode, double price, int stock, int branchId) {
        this.name = name;
        this.barcode = barcode;
        this.price = price;
        this.stock = stock;
        this.branchId = branchId;
    }

    // Getters and Setters
    public int getId() { return id; }
    public String getName() { return name; }
    public String getBarcode() { return barcode; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }
    public int getBranchId() { return branchId; }

    public void setId(int id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setBarcode(String barcode) { this.barcode = barcode; }
    public void setPrice(double price) { this.price = price; }
    public void setStock(int stock) { this.stock = stock; }
    public void setBranchId(int branchId) { this.branchId = branchId; }
}                                                       package com.supermarket.application.services;

import com.supermarket.application.models.Product;
import com.supermarket.data.dao.ProductDAO;
import java.sql.SQLException;
import java.util.List;

public class ProductService {
    private final ProductDAO productDAO;

    public ProductService() {
        this.productDAO = new ProductDAO();
    }

    // Add a new product with validation
    public void addProduct(Product product) throws SQLException, IllegalArgumentException {
        if (product.getPrice() <= 0) {
            throw new IllegalArgumentException("Price must be greater than 0.");
        }
        if (product.getStock() < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        productDAO.addProduct(product);
    }


    // Get all products
    public List<Product> getAllProducts(int branchId) throws SQLException {
        return productDAO.getAllProducts(branchId);
    }

    // Update a product
    public void updateProduct(Product product) throws SQLException, IllegalArgumentException {
        if (product.getPrice() <= 0) {
            throw new IllegalArgumentException("Price must be greater than 0.");
        }
        if (product.getStock() < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        productDAO.updateProduct(product);
    }

    // Delete a product
    public void deleteProduct(int id) throws SQLException {
        productDAO.deleteProduct(id);
    }



}                                                       package com.supermarket.data.dao;

import com.supermarket.application.models.Product;
import com.supermarket.data.DatabaseConnection;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class ProductDAO {
    public void addProduct(Product product) throws SQLException {
        String sql = "INSERT INTO products (name, barcode, price, stock, branch_id) VALUES (?, ?, ?, ?, ?)";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, product.getName());
            stmt.setString(2, product.getBarcode());
            stmt.setDouble(3, product.getPrice());
            stmt.setInt(4, product.getStock());
            stmt.setInt(5, product.getBranchId());
            stmt.executeUpdate();
        }
    }

    public List<Product> getAllProducts(int branchId) throws SQLException {
        List<Product> products = new ArrayList<>();
        String sql = "SELECT * FROM products WHERE branch_id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, branchId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    products.add(new Product(
                            rs.getInt("id"),
                            rs.getString("name"),
                            rs.getString("barcode"),
                            rs.getDouble("price"),
                            rs.getInt("stock"),
                            rs.getInt("branch_id")
                    ));
                }
            }
        }
        return products;
    }

    public void updateProduct(Product product) throws SQLException {
        String sql = "UPDATE products SET name = ?, barcode = ?, price = ?, stock = ? WHERE id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, product.getName());
            stmt.setString(2, product.getBarcode());
            stmt.setDouble(3, product.getPrice());
            stmt.setInt(4, product.getStock());
            stmt.setInt(5, product.getId());
            stmt.executeUpdate();
        }
    }

    public void deleteProduct(int id) throws SQLException {
        String sql = "DELETE FROM products WHERE id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, id);
            stmt.executeUpdate();
        }
    }
}                                                  package com.supermarket.presentation.controllers;

import com.supermarket.application.models.Branch;
import com.supermarket.application.services.BranchService;
import com.supermarket.application.services.ProductService;
import com.supermarket.application.models.Product;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.HBox;
import javafx.util.Callback;

import java.sql.SQLException;
import java.util.List;

public class InventoryController {
    @FXML
    private ComboBox<Branch> branchComboBox; // Ensure this matches the fx:id in FXML
    @FXML
    private TableView<Product> productTable;
    @FXML
    private TableColumn<Product, Integer> idColumn;
    @FXML
    private TableColumn<Product, String> nameColumn;
    @FXML
    private TableColumn<Product, String> barcodeColumn;
    @FXML
    private TableColumn<Product, Double> priceColumn;
    @FXML
    private TableColumn<Product, Integer> stockColumn;
    @FXML
    private TextField nameField;
    @FXML
    private TextField barcodeField;
    @FXML
    private TextField priceField;
    @FXML
    private TextField stockField;

    private BranchService branchService = new BranchService();
    private final ProductService productService = new ProductService();
    private final ObservableList<Product> products = FXCollections.observableArrayList();



    @FXML
    public void initialize() {
        System.out.println("Initializing InventoryController...");

        // Set up table columns
        idColumn.setCellValueFactory(new PropertyValueFactory<>("id"));
        nameColumn.setCellValueFactory(new PropertyValueFactory<>("name"));
        barcodeColumn.setCellValueFactory(new PropertyValueFactory<>("barcode"));
        priceColumn.setCellValueFactory(new PropertyValueFactory<>("price"));
        stockColumn.setCellValueFactory(new PropertyValueFactory<>("stock"));



        // Add Actions column with Update and Delete buttons
        TableColumn<Product, Void> actionsColumn = new TableColumn<>("Actions");
        actionsColumn.setPrefWidth(150);
        actionsColumn.setCellFactory(new Callback<TableColumn<Product, Void>, TableCell<Product, Void>>() {
            @Override
            public TableCell<Product, Void> call(TableColumn<Product, Void> param) {
                return new TableCell<Product, Void>() {
                    private final Button updateButton = new Button("Update");
                    private final Button deleteButton = new Button("Delete");

                    {
                        // Update button action
                        updateButton.setOnAction(event -> {
                            Product product = getTableView().getItems().get(getIndex());
                            updateProduct(product);
                        });

                        // Delete button action
                        deleteButton.setOnAction(event -> {
                            Product product = getTableView().getItems().get(getIndex());
                            deleteProduct(product);
                        });
                    }

                    @Override
                    protected void updateItem(Void item, boolean empty) {
                        super.updateItem(item, empty);
                        if (empty) {
                            setGraphic(null);
                        } else {
                            HBox buttons = new HBox(5, updateButton, deleteButton);
                            setGraphic(buttons);
                        }
                    }
                };
            }
        });

        // Add the Actions column to the table
        productTable.getColumns().add(actionsColumn);

        // Add listener for product selection
        productTable.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                // Populate input fields with selected product's data
                nameField.setText(newValue.getName());
                barcodeField.setText(newValue.getBarcode());
                priceField.setText(String.valueOf(newValue.getPrice()));
                stockField.setText(String.valueOf(newValue.getStock()));
            }
        });

        try {
            // Load branches into the ComboBox
            List<Branch> branches = branchService.getAllBranches();
            branchComboBox.setItems(FXCollections.observableArrayList(branches));
            System.out.println("Branches loaded: " + branches.size());

            // Add listener for branch selection
            branchComboBox.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
                if (newValue != null) {
                    System.out.println("Selected branch: " + newValue.getName());
                    loadProducts(newValue.getId());
                }
            });
        } catch (SQLException e) {
            showError("Failed to load branches: " + e.getMessage());
        }
    }

    private void loadProducts(int branchId) {
        try {
            products.clear();
            List<Product> productList = productService.getAllProducts(branchId);
            products.addAll(productList);
            productTable.setItems(products);
            System.out.println("Products loaded: " + productList.size());
        } catch (SQLException e) {
            showError("Failed to load products: " + e.getMessage());
        }
    }

    @FXML
    private void addProduct() {
        try {
            String name = nameField.getText();
            String barcode = barcodeField.getText();
            double price = Double.parseDouble(priceField.getText());
            int stock = Integer.parseInt(stockField.getText());
            int branchId = branchComboBox.getValue().getId();

            Product product = new Product(name, barcode, price, stock, branchId);
            productService.addProduct(product);
            loadProducts(branchId);

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (NumberFormatException e) {
            showError("Invalid input. Please check the price and stock fields.");
        } catch (SQLException e) {
            showError("Failed to add product: " + e.getMessage());
        } catch (NullPointerException e) {
            showError("Please select a branch before adding a product.");
        }
    }
    @FXML
    private void updateProduct(Product product) {
        try {
            // Get updated values from input fields
            String name = nameField.getText();
            String barcode = barcodeField.getText();
            double price = Double.parseDouble(priceField.getText());
            int stock = Integer.parseInt(stockField.getText());

            // Update the selected product
            product.setName(name);
            product.setBarcode(barcode);
            product.setPrice(price);
            product.setStock(stock);

            // Save changes to the database
            productService.updateProduct(product);

            // Refresh the table
            loadProducts(product.getBranchId());

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (NumberFormatException e) {
            showError("Invalid input. Please check the price and stock fields.");
        } catch (SQLException e) {
            showError("Failed to update product: " + e.getMessage());
        }
    }

    @FXML
    private void deleteProduct(Product product) {
        try {
            // Delete the selected product from the database
            productService.deleteProduct(product.getId());

            // Refresh the table
            loadProducts(product.getBranchId());

            // Clear input fields
            nameField.clear();
            barcodeField.clear();
            priceField.clear();
            stockField.clear();
        } catch (SQLException e) {
            showError("Failed to delete product: " + e.getMessage());
        }
    }

    private void showError(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}                                                <?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.HBox?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.Button?>
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.supermarket.presentation.controllers.InventoryController" spacing="10">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Title -->
    <Label text="Product Management" style="-fx-font-size: 20; -fx-font-weight: bold;" />

    <!-- Branch Selection -->
    <HBox spacing="10">
        <ComboBox fx:id="branchComboBox" promptText="Select Branch" prefWidth="200" />
    </HBox>

    <!-- Input Fields -->
    <HBox spacing="10">
        <TextField fx:id="nameField" promptText="Enter product name" prefWidth="150" />
        <TextField fx:id="barcodeField" promptText="Enter barcode" prefWidth="150" />
        <TextField fx:id="priceField" promptText="Enter price" prefWidth="100" />
        <TextField fx:id="stockField" promptText="Enter stock" prefWidth="100" />
        <Button text="Add Product" onAction="#addProduct" style="-fx-font-weight: bold;" />
    </HBox>

    <!-- Product Table -->
    <TableView fx:id="productTable" prefHeight="300">
        <columns>
            <TableColumn fx:id="idColumn" text="ID" prefWidth="50" />
            <TableColumn fx:id="nameColumn" text="Name" prefWidth="150" />
            <TableColumn fx:id="barcodeColumn" text="Barcode" prefWidth="150" />
            <TableColumn fx:id="priceColumn" text="Price" prefWidth="100" />
            <TableColumn fx:id="stockColumn" text="Stock" prefWidth="100" />
        </columns>
    </TableView>
</VBox>                                      package com.supermarket.application.models;

import java.util.Date;
import java.util.List;

public class Sale {
    private int id;
    private Date saleDate;
    private List<com.supermarket.application.models.Product> products;
    private double totalPrice;
    private double discount;
    private int branchId;

    // Constructor
    public Sale(int id, Date saleDate, List<com.supermarket.application.models.Product> products, double totalPrice, double discount, int branchId) {
        this.id = id;
        this.saleDate = saleDate;
        this.products = products;
        this.totalPrice = totalPrice;
        this.discount= discount;
        this.branchId= branchId;

    }

    // Getters and Setters
    // Getters and Setters
    public double getDiscount() { return discount; }
    public int getId() { return id; }
    public Date getSaleDate() { return saleDate; }
    public List<com.supermarket.application.models.Product> getProducts() { return products; }
    public double getTotalPrice() { return totalPrice; }
    public int getBranchId() { return branchId; }

    public void setId(int id) { this.id = id; }
    public void setDiscount(double discount) { this.discount = discount; }
    public void setSaleDate(Date saleDate) { this.saleDate = saleDate; }
    public void setProducts(List<com.supermarket.application.models.Product> products) { this.products = products; }
    public void setTotalPrice(double totalPrice) { this.totalPrice = totalPrice; }
    public void setBranchId(int branchId) { this.branchId = branchId; }
}                                            package com.supermarket.application.services;

import com.supermarket.data.dao.SalesDAO;
import com.supermarket.application.models.Sale;

import java.sql.SQLException;
import java.util.Date; // Use java.util.Date
import java.util.List;

public class SalesService {
    private final SalesDAO saleDAO = new SalesDAO();
    public void addSale(Sale sale) throws SQLException {
        saleDAO.addSale(sale);
    }

    public void processSale(Sale sale) throws SQLException {
        double totalPrice = sale.getTotalPrice();
        double discount = sale.getDiscount();
        double finalPrice = totalPrice - (totalPrice * discount / 100); // Apply discount
        sale.setTotalPrice(finalPrice);
        saleDAO.addSale(sale);
    }


    public List<Sale> getSalesForToday(int branchId) throws SQLException {
        Date date = new Date(); // Use the current date
        return saleDAO.getSalesByDate(date);
    }

    public List<Sale> getSalesByBranch(int branchId) throws SQLException {
        return saleDAO.getSalesByBranch(branchId);
    }
}                                                package com.supermarket.data.dao;

import com.supermarket.application.models.Sale;
import com.supermarket.data.DatabaseConnection;

import java.sql.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class SalesDAO {
    public void addSale(Sale sale) throws SQLException {
        String sql = "INSERT INTO sales (sale_date, total_price, discount, branch_id) VALUES (?, ?, ?, ?)";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            java.sql.Date sqlDate = new java.sql.Date(sale.getSaleDate().getTime());
            stmt.setDate(1, sqlDate);
            stmt.setDouble(2, sale.getTotalPrice());
            stmt.setDouble(3, sale.getDiscount());
            stmt.setInt(4, sale.getBranchId());
            stmt.executeUpdate();

            // Retrieve the generated sale ID
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) {
                    int saleId = rs.getInt(1);
                    sale.setId(saleId);

                    // Insert products related to the sale
                    insertSaleProducts(conn, saleId, sale.getProducts());
                }
            }
        }
    }

    private void insertSaleProducts(Connection conn, int saleId, List<com.supermarket.application.models.Product> products) throws SQLException {
        String sql = "INSERT INTO sale_products (sale_id, product_id, quantity) VALUES (?, ?, ?)";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (com.supermarket.application.models.Product product : products) {
                stmt.setInt(1, saleId);
                stmt.setInt(2, product.getId());
                stmt.setInt(3, 1); // Assuming quantity is 1 for simplicity
                stmt.executeUpdate();
            }
        }
    }

    public List<Sale> getSalesByBranch(int branchId) throws SQLException {
        List<Sale> sales = new ArrayList<>();
        String sql = "SELECT * FROM sales WHERE branch_id = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, branchId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    sales.add(new Sale(
                            rs.getInt("id"),
                            rs.getDate("sale_date"),
                            null, // Products are not fetched here
                            rs.getDouble("total_price"),
                            rs.getDouble("discount"),
                            rs.getInt("branch_id")
                    ));
                }
            }
        }
        return sales;
    }

    public List<Sale> getSalesByDate(Date date) throws SQLException {
        List<Sale> sales = new ArrayList<>();
        String sql = "SELECT * FROM sales WHERE sale_date = ?";
        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            java.sql.Date sqlDate = new java.sql.Date(date.getTime());
            stmt.setDate(1, sqlDate);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    Sale sale = new Sale(
                            rs.getInt("id"),
                            rs.getDate("sale_date"),
                            null, // Products are not fetched here
                            rs.getDouble("total_price"),
                            rs.getDouble("discount"),
                            rs.getInt("branch_id")
                    );
                    sales.add(sale);
                }
            }
        } catch (SQLException e) {
            System.err.println("Error fetching sales by date: " + e.getMessage());
            throw e;
        }
        return sales;
    }
}                                                           package com.supermarket.presentation.controllers;

import com.supermarket.application.models.Branch;
import com.supermarket.application.services.BranchService;
import com.supermarket.application.services.ProductService;
import com.supermarket.application.services.SalesService;
import com.supermarket.application.models.Product;
import com.supermarket.application.models.Sale;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;

import java.sql.SQLException;
import java.util.Date;
import java.util.List;

public class SalesController {
    @FXML
    private ComboBox<Branch> branchComboBox;
    @FXML
    private TableView<Product> productTable;
    @FXML
    private TableColumn<Product, String> nameColumn;
    @FXML
    private TableColumn<Product, Double> priceColumn;
    @FXML
    private TableColumn<Product, Integer> stockColumn;
    @FXML
    private TextField quantityField;
    @FXML
    private TextField discountField;
    @FXML
    private TextField totalPriceField;

    private final BranchService branchService = new BranchService();
    private final ProductService productService = new ProductService();
    private final SalesService salesService = new SalesService();
    private final ObservableList<Product> products = FXCollections.observableArrayList();
    private final ObservableList<Product> cart = FXCollections.observableArrayList();

    @FXML
    public void initialize() {
        branchComboBox.getItems().add(new Branch(1, "Main Branch", "Location 1"));

        nameColumn.setCellValueFactory(new PropertyValueFactory<>("name"));
        priceColumn.setCellValueFactory(new PropertyValueFactory<>("price"));
        stockColumn.setCellValueFactory(new PropertyValueFactory<>("stock"));

        try {
            List<Branch> branches = branchService.getAllBranches();
            branchComboBox.setItems(FXCollections.observableArrayList(branches));
            System.out.println("Branches to be set in ComboBox: " + branches.size());


            branchComboBox.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
                if (newValue != null) {
                    loadProducts(newValue.getId());
                }
            });
        } catch (SQLException e) {
            showError("Failed to load branches: " + e.getMessage());
        }
    }

    private void loadProducts(int branchId) {
        try {
            products.clear();
            products.addAll(productService.getAllProducts(branchId));
            productTable.setItems(products);
        } catch (SQLException e) {
            showError("Failed to load products: " + e.getMessage());
        }
    }

    @FXML
    private void addToCart() {
        Product selectedProduct = productTable.getSelectionModel().getSelectedItem();
        if (selectedProduct != null) {
            int quantity = 1;
            try {
                quantity = Integer.parseInt(quantityField.getText());
                if (quantity <= 0) {
                    showError("Quantity must be a positive number.");
                    return;
                }
            } catch (NumberFormatException e) {
                quantity = 1;
            }

            cart.add(selectedProduct);
            updateTotalPrice();
        } else {
            showError("Please select a product to add to the cart.");
        }
    }

    private void updateTotalPrice() {
        double total = cart.stream().mapToDouble(Product::getPrice).sum();
        double discount = 0;
        try {
            discount = Double.parseDouble(discountField.getText());
            if (discount < 0 || discount > 100) {
                showError("Discount must be between 0 and 100.");
                return;
            }
        } catch (NumberFormatException e) {
            discount = 0;
        }

        double discountedTotal = total - (total * discount / 100);
        totalPriceField.setText(String.valueOf(discountedTotal));
    }

    @FXML
    private void processSale() {
        if (cart.isEmpty()) {
            showError("The cart is empty. Please add products before processing the sale.");
            return;
        }

        try {
            int branchId = branchComboBox.getValue().getId();
            double totalPrice = Double.parseDouble(totalPriceField.getText());
            double discount = Double.parseDouble(discountField.getText());

            Sale sale = new Sale(0, new Date(), cart, totalPrice, discount, branchId);
            salesService.addSale(sale);

            cart.clear();
            updateTotalPrice();
            showSuccess("Sale processed successfully!");
        } catch (SQLException e) {
            showError("Failed to process sale: " + e.getMessage());
        }
    }

    private void showError(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }

    private void showSuccess(String message) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Success");
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}                                                 <?xml version="1.0" encoding="UTF-8"?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.ComboBox?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.cell.PropertyValueFactory?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.supermarket.presentation.controllers.SalesController" spacing="10">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Title -->
    <Label text="Sales Management" style="-fx-font-size: 20; -fx-font-weight: bold;" />

    <!-- Branch Selection -->
    <HBox spacing="10">
        <Label text="Select Branch:" />
        <ComboBox fx:id="branchComboBox" promptText="Select Branch" prefWidth="200" />
    </HBox>

    <!-- Product Table -->
    <TableView fx:id="productTable" prefHeight="200">
        <columns>
            <TableColumn fx:id="nameColumn" text="Name" prefWidth="150">
                <cellValueFactory>
                    <PropertyValueFactory property="name" />
                </cellValueFactory>
            </TableColumn>
            <TableColumn fx:id="priceColumn" text="Price" prefWidth="100">
                <cellValueFactory>
                    <PropertyValueFactory property="price" />
                </cellValueFactory>
            </TableColumn>
            <TableColumn fx:id="stockColumn" text="Stock" prefWidth="100">
                <cellValueFactory>
                    <PropertyValueFactory property="stock" />
                </cellValueFactory>
            </TableColumn>
        </columns>
    </TableView>

    <!-- Quantity Field and Add to Cart Button -->
    <HBox spacing="10">
        <TextField fx:id="quantityField" promptText="Quantity" prefWidth="100" />
        <Button text="Add to Cart" onAction="#addToCart" style="-fx-font-weight: bold;" />
    </HBox>

    <!-- Discount Field -->
    <HBox spacing="10">
        <Label text="Discount (%):" />
        <TextField fx:id="discountField" promptText="Enter discount" prefWidth="100" />
    </HBox>

    <!-- Total Price -->
    <HBox spacing="10">
        <Label text="Total Price:" />
        <TextField fx:id="totalPriceField" editable="false" prefWidth="100" />
    </HBox>

    <!-- Process Sale Button -->
    <Button text="Process Sale" onAction="#processSale" style="-fx-font-weight: bold;" />
</VBox>                                         package com.supermarket.data;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.sql.Connection;
import java.sql.SQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DatabaseConnection {
    private static final Logger logger = LoggerFactory.getLogger(DatabaseConnection.class);
    private static final String DATABASE_NAME = "supermarket.db";
    private static HikariDataSource dataSource;

    static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(getDatabaseURL());
        config.setMaximumPoolSize(10);
        config.setIdleTimeout(30000);
        config.setMaxLifetime(1800000);
        config.setConnectionTimeout(10000);
        config.setAutoCommit(true);
        dataSource = new HikariDataSource(config);
    }

    public static Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    private static String getDatabaseURL() {
        // Absolute path for development (adjust based on your system)
        String dbPath = "C:\\Users\\dawit\\Desktop\\supermarket-system\\src\\main\\resources\\supermarket.db";

        // Check if the file exists
        File dbFile = new File(dbPath);
        if (!dbFile.exists()) {
            logger.error("Database file not found at: {}", dbPath);
            throw new RuntimeException("Database file not found at: " + dbPath);
        }

        // Return the JDBC URL for SQLite
        return "jdbc:sqlite:" + dbPath;
    }

    public static void closeDataSource() {
        if (dataSource != null) {
            dataSource.close();
            logger.info("Database connection pool closed.");
        }
    }
}                                                       package com.supermarket.presentation;

import com.supermarket.presentation.controllers.LoginController;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class App extends Application {
    private Stage primaryStage;

    @Override
    public void start(Stage primaryStage) throws Exception {
        this.primaryStage = primaryStage;
        primaryStage.setTitle("Supermarket Management System");
        showLoginScreen();
    }

    /**
     * Static method to launch the JavaFX application.
     *
     * @param args Command-line arguments.
     */
    public static void launchApp(String[] args) {
        launch(args); // Starts the JavaFX application
    }

    /**
     * Displays the login screen.
     */
    private void showLoginScreen() {
        try {
            // Debug: Print the path to the FXML file
            System.out.println("Loading FXML from: " + getClass().getResource("/fxml/login.fxml"));
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/login.fxml"));
            Parent root = loader.load();
            LoginController controller = loader.getController(); // Get the controller instance
            controller.setPrimaryStage(primaryStage); // Pass the primaryStage reference
            Scene scene = new Scene(root, 400, 300); // Adjust size as needed
            primaryStage.setScene(scene);
            primaryStage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the Product Management screen.
     */
    public void showProductManagement() {
        try {
            Parent root = FXMLLoader.load(getClass().getResource("/fxml/inventory.fxml"));
            primaryStage.setScene(new Scene(root, 800, 600));
            primaryStage.setTitle("Supermarket Management System - Product Management");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads the Sales Management screen.
     */
    public void showSalesManagement() {
        try {
            Parent root = FXMLLoader.load(getClass().getResource("/fxml/sales.fxml"));
            primaryStage.setScene(new Scene(root, 800, 600));
            primaryStage.setTitle("Supermarket Management System - Sales Management");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}                                               package com.supermarket;

import com.supermarket.presentation.App;

public class Main {
    public static void main(String[] args) {
        // Delegate control to the App class, which extends Application
        App.launchApp(args);
    }
}                                     <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.supermarket</groupId>
    <artifactId>supermarket-management-system</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>Supermarket Management System</name>
    <description>Supermarket Management System for Inventory, Sales, and Reports</description>
    <!-- Properties for Java version and encoding -->
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <encoding>UTF-8</encoding>
        <javafx.version>19</javafx.version>
        <sqlite.version>3.36.0.3</sqlite.version>
        <junit.version>5.10.2</junit.version>
        <commons-lang3.version>3.12.0</commons-lang3.version>
        <apache.poi.version>5.2.3</apache.poi.version> <!-- Added for Excel reporting -->
        <zxing.version>3.5.1</zxing.version> <!-- Added for barcode scanning -->
    </properties>
    <!-- Dependencies -->
    <dependencies>
        <!-- JavaFX Dependencies -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>
        <!-- SQLite JDBC Driver -->
        <dependency>
            <groupId>org.xerial</groupId>
            <artifactId>sqlite-jdbc</artifactId>
            <version>${sqlite.version}</version>
        </dependency>
        <!-- JUnit 5 Dependencies for Testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- Apache Commons Lang for utility classes -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <!-- Logging with SLF4J and Logback -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.36</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.11</version>
        </dependency>
        <dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
        </dependency>
        <!-- SLF4J API -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>1.7.36</version>
            </dependency>

            <!-- Logback Implementation -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.2.11</version>
            </dependency>

        <!-- Apache POI for Excel Reporting -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>${apache.poi.version}</version>
        </dependency>
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.0.1</version>
        </dependency>
        <!-- ZXing for Barcode Scanning -->
        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>core</artifactId>
            <version>${zxing.version}</version>
        </dependency>
        <dependency>
            <groupId>com.google.zxing</groupId>
            <artifactId>javase</artifactId>
            <version>${zxing.version}</version>
        </dependency>
    </dependencies>
    <!-- Build Configuration -->
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.fxml</include>
                    <include>**/*.properties</include>
                    <include>**/*.css</include>
                </includes>
            </resource>
        </resources>

        <plugins>
            <!-- Maven Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>
            <!-- Maven Surefire Plugin for Running Tests -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0-M5</version>
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                    </includes>
                </configuration>
            </plugin>
            <!-- JavaFX Maven Plugin -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>com.supermarket.presentation.App</mainClass>
                </configuration>
            </plugin>
            <!-- Maven Jar Plugin for Packaging -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <mainClass>com.supermarket.presentation.App</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            <!-- Maven Assembly Plugin for Creating a Fat JAR -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    <archive>
                        <manifest>
                            <mainClass>com.supermarket.presentation.App</mainClass>
                        </manifest>
                    </archive>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
    <!-- Repositories Section -->
    <repositories>
        <repository>
            <id>central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </repository>
    </repositories>
    <!-- Plugin Repositories Section -->
    <pluginRepositories>
        <pluginRepository>
            <id>central</id>
            <url>https://repo.maven.apache.org/maven2</url>
        </pluginRepository>
    </pluginRepositories>
</project>                  